# Compiler determinant

В данном проекте представлен инструмент, позволяющий определить компилятор, который был использован для компиляции кода, по дизассемблеру этого самомго кода.

Процесс разработки Compiler determinant:
1. Создание базы данных:
  а) Подбор различных библиотек
  б) Сборка библиотек с использование компиляторов gcc и clang
  в) Дизассемблирование бинарных файлов полученных после сборок библиотек
  г) Объединение в общую базу данных дизассемблированных функций и прочей информации о библиотека
2. Созданией нейронной сети:
  Именно нейронная сеть хорошо подходит для данной задачи. Для разработки нейронной сети использовался Jupyter Notebook. Нейронная сеть строится на основе embedding слоя, рекурентного bidirectional LSTM слоя и выходного слоя из одного нейрона. Сеть обучается на наборе дизассемблированных функций, где каждое слово представлено токеном, а результатом работы данной сети является число 0 либо 1 (1 - использовался компилятор gcc, 0 - использовался компилятор clang)
  Шаги разработки нейронной сети:
    а) Загружается база данных и делится на наборы
    б) Дизассемблированные функции, на которых будет обучаться сеть, токенизируется, а из полученных токенов создаётся словарь (с использованием Keras Tokenizer)
    в) Обработка данных для наилучшей пригодности к обучению на них (устанавливается ограничение на максимальную и минимальную длину токенов в функции, подгонка всех токенизированных функций под один установленный размер, перемешивание функций)
    г) Обучение нейронной сети. Обучение производилось двумя способами (выбора валидационного набора данных): при первом - в качестве валидационного набора данных выступали последние 20% функций тренировочного набора данных, для второго способа использовалась библиотека KFold.
    Итог: 98,7% верных предсказаний - это наилучший результат, который показала нейронная сеть на тестовом наборе дыннчх.
    
В файлах проекта имеются:
Код из Jupyter Notebook,
Словарь с токенами,
Обученная модель нейронной сети.
